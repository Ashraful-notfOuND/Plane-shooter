#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_mixer.h>
#include <math.h>
#include <stdio.h>
#include <string.h>

#define SCREEN_WIDTH 1280
#define SCREEN_HEIGHT 720
#define PLAYER_SPEED 4.0
#define PLAYER_BULLET_SPEED 20.0
#define ALIEN_BULLET_SPEED 8.0
#define RAND_MAX 3276
#define NUM_HighScores 8
#define MAX_KEYBOARD_KEYS 350
#define MAX_SCORE_NAME_LENGTH 16
#define MAX_STRING_LENGTH 50
#define SIDE_PLAYER 0
#define SIDE_ALIEN 1
#define FPS 60
#define MAX_STARS 500
#define MAX_Menu 5
#define Title_Menue 3
#define MAX_SND_CHANNELS 8
#define SND_PLAYER_FIRE 1
#define SND_ALIEN_FIRE 2
#define SND_PLAYER_DIE 3
#define SND_ALIEN_DIE 4
#define SND_POINTS 5
#define SND_MAX 6
#define CH_ANY -1
#define CH_PLAYER 0
#define CH_ALIEN_FIRE 1
#define CH_POINTS 2
#define GLYPH_HEIGHT 28
#define GLYPH_WIDTH 18

typedef char TString16[MAX_SCORE_NAME_LENGTH];
typedef char TString50[MAX_STRING_LENGTH];

typedef enum {
    Logo,
    Highsc,
    Game,
    Menues
} TDelegating;

typedef struct {
    TDelegating logic, draw;
} TDelegate;

typedef struct TTexture {
    char name[128];
    SDL_Texture* Texture;
    struct TTexture* next;
} TTexture;

typedef struct {
    SDL_Window* Window;
    SDL_Renderer* Renderer;
    int keyboard[MAX_KEYBOARD_KEYS];
    TTexture* textureHead;
    TTexture* textureTail;
    char inputText[128];
    TDelegate delegate;
    TDelegate r_delegate;
} TApp;

typedef struct TEntity {
    double x, y, dx, dy;
    int w, h, health, reload, side;
    SDL_Texture* Texture;
    struct TEntity* next;
} TEntity;

typedef struct TExplosion {
    double x, y, dx, dy;
    int r, g, b, a;
    struct TExplosion* next;
} TExplosion;

typedef struct TDebris {
    double x, y, dx, dy;
    SDL_Rect rect;
    SDL_Texture* Texture;
    int life;
    struct TDebris* next;
} TDebris;

typedef struct {
    TEntity* fighterHead;
    TEntity* fighterTail;
    TEntity* bulletHead;
    TEntity* bulletTail;
    TEntity* pointsHead;
    TEntity* pointsTail;
    TExplosion* explosionHead;
    TExplosion* explosionTail;
    TDebris* debrisHead;
    TDebris* debrisTail;
    int score;
} TStage;

typedef struct {
    int x, y, speed;
} TStar;

typedef struct {
    int x, y, r, g, b;
    TString16 Text;
    TString50 HText;
} TM_place;

typedef struct {
    TString16 name;
    int recent, score;
} THighScoreDef;

typedef THighScoreDef THighScoreArray[NUM_HighScores];
typedef THighScoreDef TnewHighScoresArray[NUM_HighScores];

typedef enum {
    TEXT_LEFT,
    TEXT_CENTER,
    TEXT_RIGHT
} TAlignment;

TApp app;
TStage stage;
TEntity* player;
TEntity* enemy;
TEntity* bullet;
TTexture* fontTexture;
TTexture* pointsTexture;
TTexture* enemyTexture;
TTexture* bulletTexture;
TTexture* alienbulletTexture;
TTexture* playerTexture;
TTexture* SDL2Texture;
TTexture* shooterTexture;
TTexture* background;
TTexture* explosionTexture;
SDL_Event Event;
int newHighScoreFlag;
int bMenue;
int exitLoop;
UInt32 gTicks;
int reveal;
int reveal_max;
int timeout;
int cursorBlink;
int backgroundX;
int enemyspawnTimer;
int resetTimer;
TM_place PM[MAX_Menu + 1];
TStar stars[MAX_STARS];
Mix_Chunk* sounds[SND_MAX];
Mix_Music* music;
THighScoreArray HighScores;
THighScoreDef newHighScore;
int SoundVol = 16;
int MusicVol = 32;
double gRemainder = 0;
byte Auswahl = 1;

void initEntity(PEntity e) {
    e->x = 0.0;
    e->dx = 0.0;
    e->w = 0;
    e->health = 0;
    e->reload = 0;
    e->side = 0;
    e->y = 0.0;
    e->dy = 0.0;
    e->h = 0;
    e->Texture = NULL;
    e->next = NULL;
}

void initDebris(PDebris e) {
    e->x = 0.0;
    e->dx = 0.0;
    e->life = 0;
    e->Texture = NULL;
    e->y = 0.0;
    e->dy = 0.0;
}

void initExplosion(PExplosion e) {
    e->x = 0.0;
    e->dx = 0.0;
    e->r = 0;
    e->g = 0;
    e->b = 0;
    e->a = 0;
    e->y = 0.0;
    e->dy = 0.0;
    e->next = NULL;
}

void initTex(PTextur te) {
    strcpy(te->name, "");
    te->Texture = NULL;
    te->next = NULL;
}

void initStageListenPointer() {
    app.textureHead = (PTextur)malloc(sizeof(TTexture));
    stage.fighterHead = (PEntity)malloc(sizeof(TEntity));
    stage.bulletHead = (PEntity)malloc(sizeof(TEntity));
    stage.explosionHead = (PExplosion)malloc(sizeof(TExplosion));
    stage.debrisHead = (PDebris)malloc(sizeof(TDebris));
    stage.pointsHead = (PEntity)malloc(sizeof(TEntity));

    initTex(app.textureHead);
    initEntity(stage.fighterHead);
    initEntity(stage.bulletHead);
    initExplosion(stage.explosionHead);
    initDebris(stage.debrisHead);
    initEntity(stage.pointsHead);

    app.textureTail = app.textureHead;
    stage.fighterTail = stage.fighterHead;
    stage.bulletTail = stage.bulletHead;
    stage.explosionTail = stage.explosionHead;
    stage.debrisTail = stage.debrisHead;
    stage.pointsTail = stage.pointsHead;
}

int collision(double x1, double y1, double w1, double h1, double x2, double y2, double w2, double h2) {
    return (x1 < x2 + w2) && (x1 + w1 > x2) && (y1 < y2 + h2) && (y1 + h1 > y2);
}

void calcSlope(double x1, double y1, double x2, double y2, double* dx, double* dy) {
    double steps = fmax(fabs(x1 - x2), fabs(y1 - y2));
    if (steps != 0.0) {
        *dx = (x1 - x2) / steps;
        *dy = (y1 - y2) / steps;
    } else {
        *dx = 0.0;
        *dy = 0.0;
    }
}

void errorMessage(char* Message1) {
    SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Error Box", Message1, NULL);
    exit(1);
}

void logMessage(char* Message1) {
    char Fmt[128];
    snprintf(Fmt, sizeof(Fmt), "File not found: %s\n", Message1);
    SDL_LogMessage(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_WARN, Fmt);
}

void loadSounds() {
    sounds[1] = Mix_LoadWAV("sound/334227__jradcoolness__laser.ogg");
    if (sounds[1] == NULL) {
        logMessage("Soundfile: \"334227__jradcoolness__laser.ogg\"");
    }

    sounds[2] = Mix_LoadWAV("sound/196914__dpoggioli__laser-gun.ogg");
    if (sounds[2] == NULL) {
        logMessage("Soundfile: \"196914__dpoggioli__laser-gun.ogg\"");
    }

    sounds[3] = Mix_LoadWAV("sound/245372__quaker540__hq-explosion.ogg");
    if (sounds[3] == NULL) {
        logMessage("Soundfile: \"245372__quaker540__hq-explosion.ogg\"");
    }

    sounds[4] = Mix_LoadWAV("sound/10 Guage Shotgun-SoundBible.com-74120584.ogg");
    if (sounds[4] == NULL) {
        logMessage("Soundfile: \"10 Guage Shotgun-SoundBible.com-74120584.ogg\"");
    }

    sounds[5] = Mix_LoadWAV("sound/342749__rhodesmas__notification-01.ogg");
    if (sounds[5] == NULL) {
        logMessage("Soundfile: \"342749__rhodesmas__notification-01.ogg\"");
    }

    Mix_VolumeChunk(sounds[1], SoundVol);
    Mix_VolumeChunk(sounds[2], SoundVol);
    Mix_VolumeChunk(sounds[3], SoundVol);
    Mix_VolumeChunk(sounds[4], SoundVol);
    Mix_VolumeChunk(sounds[5], SoundVol);
}

void loadMusic() {
    if (music != NULL) {
        Mix_HaltMusic();
        Mix_FreeMusic(music);
        music = NULL;
    }

    music = Mix_LoadMUS("music/Mercury.ogg");
    if (music == NULL) {
        logMessage("Music: \"Mercury.ogg\"");
    }

    Mix_VolumeMusic(MusicVol);
}

void playMusic(int play) {
    int m = play ? -1 : 0;
    Mix_PlayMusic(music, m);
}

void playSound(int id, int channel) {
    Mix_PlayChannel(channel, sounds[id], 0);
}

void initSounds() {
    loadSounds();
}

void blit(SDL_Texture* Texture, double x, double y) {
    SDL_Rect dest;
    dest.x = (int)x;
    dest.y = (int)y;
    SDL_QueryTexture(Texture, NULL, NULL, &dest.w, &dest.h);
    SDL_RenderCopy(app.Renderer, Texture, NULL, &dest);
}

void blitRect(SDL_Texture* Texture, SDL_Rect* src, double x, double y) {
    SDL_Rect dest;
    dest.x = (int)x;
    dest.y = (int)y;
    dest.w = src->w;
    dest.h = src->h;
    SDL_RenderCopy(app.Renderer, Texture, src, &dest);
}

void addTextureToCache(char* Lname, SDL_Texture* LTexture) {
    PTextur cache = (PTextur)malloc(sizeof(TTexture));
    initTex(cache);
    app.textureTail->next = cache;
    app.textureTail = cache;
    strcpy(cache->name, Lname);
    cache->Texture = LTexture;
}

SDL_Texture* getTexture(char* name) {
    PTextur tg = app.textureHead->next;
    while (tg != NULL) {
        if (strcmp(tg->name, name) == 0) {
            return tg->Texture;
        }
        tg = tg->next;
    }
    return NULL;
}

SDL_Texture* loadTexture(char* Pfad) {
    SDL_Texture* tl = getTexture(Pfad);
    if (tl == NULL) {
        tl = IMG_LoadTexture(app.Renderer, Pfad);
        if (tl == NULL) {
            errorMessage(SDL_GetError());
        }
        addTextureToCache(Pfad, tl);
    }
    return tl;
}

void prepareScene() {
    SDL_SetRenderDrawColor(app.Renderer, 32, 32, 32, 255);
    SDL_RenderClear(app.Renderer);
}

void presentScene() {
    SDL_RenderPresent(app.Renderer);
}

void drawText(int x, int y, int r, int g, int b, TAlignment align, char* outText) {
    int len = strlen(outText);
    SDL_Rect rect;
    switch (align) {
        case TEXT_RIGHT:
            x = x - (len * GLYPH_WIDTH);
            break;
        case TEXT_CENTER:
            x = x - (len * GLYPH_WIDTH) / 2;
            break;
    }
    char outTextUpper[MAX_STRING_LENGTH];
    for (int i = 0; i < len; i++) {
        outTextUpper[i] = toupper(outText[i]);
    }
    outTextUpper[len] = '\0';
    rect.w = GLYPH_WIDTH;
    rect.h = GLYPH_HEIGHT;
    rect.y = 0;
    SDL_SetTextureColorMod(fontTexture, r, g, b);
    for (int i = 0; i < len; i++) {
        if (outTextUpper[i] >= ' ' && outTextUpper[i] <= 'Z') {
            rect.x = (outTextUpper[i] - ' ') * GLYPH_WIDTH;
            blitRect(fontTexture, &rect, x, y);
            x += GLYPH_WIDTH;
        }
    }
}

char* numberfill(int a) {
    static char FMT[MAX_SCORE_NAME_LENGTH];
    sprintf(FMT, "[%.3d]", a);
    return FMT;
}

void initFonts() {
    fontTexture = loadTexture("gfx/font.png");
}

void emptyHighScore() {
    for (int i = 0; i < NUM_HighScores; i++) {
        HighScores[i].score = NUM_HighScores - i;
        strcpy(HighScores[i].name, "ANONYMOUS");
    }
}

void readHighScore() {
    FILE* filein = fopen("gfx/HighScore.txt", "r");
    if (filein == NULL) {
        emptyHighScore();
    } else {
        for (int i = 0; i < NUM_HighScores; i++) {
            fscanf(filein, "%s", HighScores[i].name);
            fscanf(filein, "%d", &HighScores[i].score);
        }
        fclose(filein);
    }
}

void writeHighScore() {
    FILE* fileout = fopen("gfx/HighScore.txt", "w");
    for (int i = 0; i < NUM_HighScores; i++) {
        fprintf(fileout, "%s\n", HighScores[i].name);
        fprintf(fileout, "%d\n", HighScores[i].score);
    }
    fclose(fileout);
}

void Order(int* p, int* q) {
    int temp = *p;
    *p = *q;
    *q = temp;
}

void Bubble(THighScoreDef B[], int n) {
    for (int i = 0; i < n; i++) {
        int min = i;
        for (int j = i + 1; j <= n; j++) {
            if (B[min].score < B[j].score) {
                min = j;
            }
            if (B[i].score < B[min].score) {
                Order(&B[i].score, &B[min].score);
                Order(&B[i].recent, &B[min].recent);
            }
        }
    }
}

void addHighScore(int score) {
    THighScoreArray newHighScores;
    for (int k = 0; k < NUM_HighScores; k++) {
        newHighScores[k] = HighScores[k];
        newHighScores[k].recent = 0;
        if (newHighScores[k].score == score && strcmp(newHighScores[k].name, "ANONYMOUS") == 0) {
            newHighScores[k].score = 0;
        }
    }
    newHighScores[NUM_HighScores].score = score;
    newHighScores[NUM_HighScores].recent = 1;
    Bubble(newHighScores, NUM_HighScores);
    for (int k = 0; k < NUM_HighScores; k++) {
        HighScores[k] = newHighScores[k];
        if (newHighScores[k].recent == 1) {
            HighScores[k].recent = 1;
            newHighScoreFlag = 1;
        }
    }
}

void doNameInput() {
    int n = strlen(newHighScore.name);
    for (int i = 0; i < strlen(app.inputText); i++) {
        char c = toupper(app.inputText[i]);
        if (n < MAX_SCORE_NAME_LENGTH - 1 && c >= ' ' && c <= 'Z') {
            newHighScore.name[n] = c;
            n++;
            newHighScore.name[n] = '\0';
        }
    }
    if (n > 0 && app.keyboard[SDL_SCANCODE_BACKSPACE] == 1) {
        newHighScore.name[n - 1] = '\0';
        app.keyboard[SDL_SCANCODE_BACKSPACE] = 0;
    }
    if (app.keyboard[SDL_SCANCODE_RETURN] == 1) {
        if (n == 0) {
            strcpy(newHighScore.name, "ANONYMOUS");
        }
        for (int i = 0; i < NUM_HighScores; i++) {
            if (HighScores[i].recent == 1) {
                strcpy(HighScores[i].name, newHighScore.name);
                newHighScore.name[0] = '\0';
            }
        }
        newHighScoreFlag = 0;
    }
}

void drawNameInput() {
    SDL_Rect r;
    drawText(SCREEN_WIDTH / 2, 70, 255, 255, 255, TEXT_CENTER, "CONGRATULATIONS, YOU'VE GAINED A HIGHSCORE!");
    drawText(SCREEN_WIDTH / 2, 120, 255, 255, 255, TEXT_CENTER, "ENTER YOUR NAME BELOW:");
    drawText(SCREEN_WIDTH / 2, 250, 128, 255, 128, TEXT_CENTER, newHighScore.name);
    if (cursorBlink < (FPS / 2)) {
        r.x = (SCREEN_WIDTH / 2) + (strlen(newHighScore.name) * GLYPH_WIDTH) / 2 + 5;
        r.y = 250;
        r.w = GLYPH_WIDTH;
        r.h = GLYPH_HEIGHT;
        SDL_SetRenderDrawColor(app.Renderer, 0, 255, 0, 255);
        SDL_RenderFillRect(app.Renderer, &r);
    }
    drawText(SCREEN_WIDTH / 2, 625, 255, 255, 255, TEXT_CENTER, "PRESS RETURN WHEN FINISHED");
}

void drawHighScores() {
    int y = 150;
    drawText(SCREEN_WIDTH / 2, 70, 255, 255, 255, TEXT_CENTER, "HIGHSCORES");
    for (int i = 0; i < NUM_HighScores; i++) {
        int r = 255, g = 255, b = 255, o = MAX_SCORE_NAME_LENGTH - strlen(HighScores[i].name) + 5;
        char Fmt[MAX_STRING_LENGTH];
        char a[MAX_STRING_LENGTH];
        snprintf(Fmt, sizeof(Fmt), "[#%.d %s %-*.*s %.3d]", i + 1, HighScores[i].name, o, o, "....................", HighScores[i].score);
        if (HighScores[i].recent == 1) {
            b = 0;
        }
        drawText(SCREEN_WIDTH / 2, y, r, g, b, TEXT_CENTER, Fmt);
        y += 50;
    }
}

void initHighScore() {
    app.delegate.logic = HighSC;
    app.delegate.draw = HighSC;
    memset(app.keyboard, 0, sizeof(app.keyboard));     // empty keyboard buffer
    timeout = FPS * 5;
}

void initHighScoreTable() {
    readHighScore();
    newHighScoreFlag = 0;
    cursorBlink = 0;
}

#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define MAX_STARS 100
#define RAND_MAX 32767
#define FPS 60
#define TEXT_LEFT 0
#define TEXT_RIGHT 1
#define CH_POINTS 0
#define SND_POINTS 0

typedef struct TSDL_Rect {
    int x, y, w, h;
} TSDL_Rect;

typedef struct PExplosion {
    double x, y;
    double dx, dy;
    int r, g, b, a;
    struct PExplosion* next;
} PExplosion;

typedef struct PDebris {
    int x, y, dx, dy, life;
    TSDL_Rect rect;
    SDL_Texture* Texture;
    struct PDebris* next;
} PDebris;

typedef struct PEntity {
    int x, y, dx, dy, w, h, health;
    SDL_Texture* Texture;
    struct PEntity* next;
} PEntity;

typedef struct Stage {
    int score;
    SDL_Texture* explosionTexture;
    PExplosion* explosionHead;
    PExplosion* explosionTail;
    PDebris* debrisHead;
    PDebris* debrisTail;
    PEntity* pointsHead;
    PEntity* pointsTail;
    PEntity* fighterHead;
    PEntity* bulletHead;
} Stage;

Stage stage;

int backgroundX = 0;
SDL_Texture* background;
SDL_Texture* pointsTexture;

void initEntity(PEntity* e) {
    // Initialization code for an entity
}

void initDebris(PDebris* d) {
    // Initialization code for debris
}

void initExplosion(PExplosion* e) {
    // Initialization code for explosions
}

void drawText(int x, int y, int r, int g, int b, int alignment, const char* text) {
    // Function to draw text on the screen
}

int RANDOM(int max) {
    return rand() % max;
}

void blit(SDL_Texture* texture, int x, int y) {
    // Function to blit a texture at (x, y)
}

int collision(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2) {
    // Function to check collision between two rectangles
}

void playSound(int soundID, int channel) {
    // Function to play a sound on a specified channel
}

char* numberfill(int num) {
    // Function to format a number as a string
    // (you need to implement this)
}

void drawBackground() {
    int x = backgroundX;
    while (x < SCREEN_WIDTH) {
        TSDL_Rect dest;
        dest.x = x;
        dest.y = 0;
        dest.w = SCREEN_WIDTH;
        dest.h = SCREEN_HEIGHT;
        SDL_RenderCopy(app.Renderer, background, NULL, &dest);
        x += SCREEN_WIDTH;
    }
}

void drawStarfield() {
    for (int i = 0; i < MAX_STARS; i++) {
        int c = 32 * stars[i].speed;
        if (c > 255) c = 255;
        SDL_SetRenderDrawColor(app.Renderer, c, c, c, 255);
        SDL_RenderDrawLine(app.Renderer, stars[i].x, stars[i].y, stars[i].x + 3, stars[i].y);
    }
}

void doStarField() {
    for (int i = 0; i < MAX_STARS; i++) {
        stars[i].x -= stars[i].speed;
        if (stars[i].x < 0)
            stars[i].x += SCREEN_WIDTH;
    }
}

void doBackGround() {
    backgroundX--;
    if (backgroundX < -SCREEN_WIDTH)
        backgroundX = 0;
}

void initStarfield() {
    for (int i = 0; i < MAX_STARS; i++) {
        stars[i].x = RANDOM(RAND_MAX) % SCREEN_WIDTH;
        stars[i].y = RANDOM(RAND_MAX) % SCREEN_HEIGHT;
        stars[i].speed = 1 + RANDOM(RAND_MAX) % 8;
    }
}

void initBackground() {
    background = loadTexture("gfx/background.png");
    backgroundX = 0;
}

void drawHud() {
    drawText(10, 10, 255, 255, 255, TEXT_LEFT, "SCORE: " + numberfill(stage.score));
    if (stage.score < HighScores[0].score) {
        drawText(SCREEN_WIDTH - 10, 10, 255, 255, 255, TEXT_RIGHT, "MAX HIGHSCORE: " + numberfill(HighScores[0].score));
    } else {
        drawText(SCREEN_WIDTH - 10, 10, 0, 255, 0, TEXT_RIGHT, "NEW HIGHSCORE: " + numberfill(stage.score));
    }
}

void drawExplosions() {
    SDL_SetRenderDrawBlendMode(app.Renderer, SDL_Blendmode_ADD);
    SDL_SetTextureBlendMode(explosionTexture, SDL_Blendmode_ADD);
    PExplosion* e = stage.explosionHead->next;
    while (e != NULL) {
        SDL_SetTextureColorMod(explosionTexture, e->r, e->g, e->b);
        SDL_SetTextureAlphaMod(explosionTexture, e->a);
        blit(explosionTexture, e->x, e->y);
        e = e->next;
    }
    SDL_SetRenderDrawBlendMode(app.Renderer, SDL_BLENDMODE_NONE);
}

void drawDebris() {
    PDebris* d = stage.debrisHead->next;
    while (d != NULL) {
        blitRect(d->Texture, &d->rect, d->x, d->y);
        d = d->next;
    }
}

void drawBullets() {
    PEntity* b = stage.bulletHead->next;
    while (b != NULL) {
        blit(b->Texture, b->x, b->y);
        b = b->next;
    }
}

void drawFighters() {
    PEntity* e = stage.fighterHead->next;
    while (e != NULL) {
        blit(e->Texture, e->x, e->y);
        e = e->next;
    }
}

void drawPointsPods() {
    PEntity* p = stage.pointsHead->next;
    while (p != NULL) {
        if (p->health > FPS * 2 || p->health % 12 < 6) {
            blit(p->Texture, p->x, p->y);
        }
        p = p->next;
    }
}

void draw_Game() {
    drawBackground();
    drawStarfield();
    drawPointsPods();
    drawFighters();
    drawDebris();
    drawExplosions();
    drawBullets();
    drawHud();
}

void addPointsPod(int x, int y) {
    PEntity* e = malloc(sizeof(PEntity));
    initEntity(e);
    stage.pointsTail->next = e;
    stage.pointsTail = e;
    e->x = x;
    e->y = y;
    e->dx = -1 * (RANDOM(RAND_MAX) % 5 - 0.1);
    e->dy = RANDOM(RAND_MAX) % 5 - RANDOM(RAND_MAX) % 5;
    e->health = FPS * 10;
    e->Texture = pointsTexture;
    TSDL_Rect dest;
    SDL_QueryTexture(e->Texture, NULL, NULL, &dest.w, &dest.h);
    e->w = dest.w;
    e->h = dest.h;
    e->x = e->x - (e->w / 2);
    e->y = e->y - (e->h / 2);
}

void addDebris(PEntity* e) {
    int w = e->w / 2;
    int h = e->h / 2;
    int x = 0, y = 0;
    while (y <= h) {
        while (x <= w) {
            PDebris* d = malloc(sizeof(PDebris));
            initDebris(d);
            stage.debrisTail->next = d;
            stage.debrisTail = d;
            d->x = e->x + (e->w / 2);
            d->y = e->y + (e->h / 2);
            d->dx = RANDOM(RAND_MAX) % 5 - RANDOM(RAND_MAX) % 5;
            d->dy = -1 * (5 + RANDOM(RAND_MAX) % 12);
            d->life = FPS * 2;
            d->Texture = e->Texture;
            d->rect.x = x;
            d->rect.y = y;
            d->rect.w = w;
            d->rect.h = h;
            x += w;
        }
        x = 0;
        y += h;
    }
}

void addExplosions(double x, double y, int num) {
    for (int i = 0; i < num; i++) {
        PExplosion* e = malloc(sizeof(PExplosion));
        initExplosion(e);
        stage.explosionTail->next = e;
        stage.explosionTail = e;
        e->x = x + RANDOM(RAND_MAX) % 32 - RANDOM(RAND_MAX) % 32;
        e->y = y + RANDOM(RAND_MAX) % 32 - RANDOM(RAND_MAX) % 32;
        e->dx = RANDOM(RAND_MAX) % 10 - RANDOM(RAND_MAX) % 10;
        e->dy = RANDOM(RAND_MAX) % 10 - RANDOM(RAND_MAX) % 10;
        e->dx = e->dx / 10.0;
        e->dy = e->dy / 10.0;
        int randomCase = RANDOM(RAND_MAX) % 4;
        switch (randomCase) {
            case 0:
                e->r = 255;
                break;
            case 1:
                e->r = 255;
                e->g = 128;
                break;
            case 2:
                e->r = 255;
                e->g = 255;
                break;
            default:
                e->r = 255;
                e->g = 255;
                e->b = 255;
                break;
        }
        e->a = RANDOM(RAND_MAX) % (FPS * 3);
    }
}

void doPointsPods() {
    PEntity* e;
    PEntity* prev = stage.pointsHead;
    e = stage.pointsHead->next;
    while (e != NULL) {
        if (e->x < 0) {
            e->x = 0;
            e->dx = -1 * e->dx;
        }
        if (e->x + e->w > SCREEN_WIDTH) {
            e->x = SCREEN_WIDTH - e->w;
            e->dx = -1 * e->dx;
        }
        if (e->y < 0) {
            e->y = 0;
            e->dy = -1 * e->dy;
        }
        if (e->y + e->h > SCREEN_HEIGHT) {
            e->y = SCREEN_HEIGHT - e->h;
            e->dy = -1 * e->dy;
        }
        e->x += e->dx;
        e->y += e->dy;
        e->health--;
        if (player != NULL && collision(e->x, e->y, e->w, e->h, player->x, player->y, player->w, player->h)) {
            e->health = 0;
            stage.score++;
            playSound(SND_POINTS, CH_POINTS);
        }
        if (e->health <= 0) {
            if (e == stage.pointsTail) {
                stage.pointsTail = prev;
            }
            prev->next = e->next;
            free(e);
            e = prev;
        }
        prev = e;
        e = e->next;
    }
}

void doDebris() {
    PDebris* d;
    PDebris* prev = stage.debrisHead;
    d = stage.debrisHead->next;
    while (d != NULL) {
        d->x = d->x + d->dx;
        d->y = d->y + d->dy;
        d->dy = d->dy + 0.5;
        d->life--;
        if (d->life <= 0) {
            if (d == stage.debrisTail) {
                stage.debrisTail = prev;
            }
            prev->next = d->next;
            free(d);
            d = prev;
        }
        prev = d;
        d = d->next;
    }
}

typedef struct {
  int x, y, w, h, dx, dy, health, side, reload;
  SDL_Texture *Texture;
} Entity;

#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 480
#define FPS 60
#define ALIEN_BULLET_SPEED 5

Entity *player;
Entity *stageHead;
Entity *stageTail;

void doDebris() {
  Entity *d, *prev;

  prev = stageHead;
  d = stageHead->next;
  while (d != NULL) {
    d->x += d->dx;
    d->y += d->dy;
    d->dy += 0.5;
    d->health--;
    if (d->health <= 0) {
      if (d == stageTail) {
        stageTail = prev;
      }
      prev->next = d->next;
      free(d);
      d = prev;
    }
    prev = d;
    d = d->next;
  }
}

void doExplosions() {
  Entity *e, *prev;

  prev = stageHead;
  e = stageHead->next;
  while (e != NULL) {
    e->x += e->dx;
    e->y += e->dy;
    e->alpha--;
    if (e->alpha <= 0) {
      if (e == stageTail) {
        stageTail = prev;
      }
      prev->next = e->next;
      free(e);
      e = prev;
    }
    prev = e;
    e = e->next;
  }
}

void clipPlayer() {
  if (player != NULL) {
    if (player->x < 0) {
      player->x = 0;
    }
    if (player->y < 0) {
      player->y = 0;
    }
    if (player->x > (SCREEN_WIDTH - player->w)) {
      player->x = SCREEN_WIDTH - player->w;
    }
    if (player->y > (SCREEN_HEIGHT - player->h)) {
      player->y = SCREEN_HEIGHT - player->h;
    }
  }
}

void spawnEnemies() {
  Entity *enemy;
  SDL_Rect dest;

  enemySpawnTimer--;
  if (enemySpawnTimer <= 0) {
    enemy = malloc(sizeof(Entity));
    initEntity(enemy);
    stageTail->next = enemy;
    stageTail = enemy;
    enemy->Texture = enemyTexture;
    SDL_QueryTexture(enemy->Texture, NULL, NULL, &dest.w, &dest.h);
    enemy->w = dest.w;
    enemy->h = dest.h;
    enemy->x = SCREEN_WIDTH;
    enemy->y = rand() % (SCREEN_HEIGHT - enemy->h);
    enemy->dx = -1 * (2 + (rand() % 4));
    enemy->dy = -100 + (rand() % 200);
    enemy->dy /= 100;
    enemy->side = SIDE_ALIEN;
    enemy->health = 1;
    enemy->reload = FPS * (1 + (rand() % 3));
    enemySpawnTimer = 30 + (rand() % FPS);
  }
}

bool bulletHitFighter(Entity *b, Entity *f) {
  if (f->side != b->side) {
    if (collision(b->x, b->y, b->w, b->h, f->x, f->y, f->w, f->h)) {
      b->health = 0;
      f->health = 0;
      addExplosions(f->x, f->y, 32);
      addDebris(f);
      if (f == player) {
        playSound(SND_PLAYER_DIE, CH_PLAYER);
      } else {
        addPointsPod(f->x + (f->w / 2), f->y + (f->h / 2));
        playSound(SND_ALIEN_DIE, CH_ANY);
      }
      return true;
    }
void doBullets() {
  Entity *b, *prev;

  prev = stageHead;
  b = stageHead->next;
  while (b != NULL) {
    b->x += b->dx;
    b->y += b->dy;
    if ((bulletHitFighter(b) == true) OR (b->x < -b->w) OR (b->y < -b->h) OR
        (b->x > SCREEN_WIDTH) OR (b->y > SCREEN_HEIGHT)) {
      if (b == stageTail) {
        stageTail = prev;
      }
      prev->next = b->next;
      free(b);
      b = prev;
    }
    prev = b;
    b = b->next;
  }
}

void doFighters() {
  Entity *e, *prev;

  prev = stageHead;
  e = stageHead->next;
  while (e != NULL) {
    e->x += e->dx;
    e->y += e->dy;
    if ((e != player) AND (e->x < -e->w)) {
      e->health = 0;
    }
    if (e->health == 0) {
      if (e == player) {
        player = NULL;
      }
      if (e == stageTail) {
        stageTail = prev;
      }
      prev->next = e->next;
      free(e);
      e = prev;
    }
    prev = e;
    e = e->next;
  }
}

void fireAlienbullet(Entity *e) {
  Entity *bullet;
  SDL_Rect dest;

  bullet = malloc(sizeof(Entity));
  initEntity(bullet);
  stageTail->next = bullet;
  stageTail = bullet;
  bullet->x = e->x;
  bullet->y = e->y;
  bullet->health = 1;
  bullet->Texture = alienbulletTexture;
  SDL_QueryTexture(bullet->Texture, NULL, NULL, &dest.w, &dest.h);
  bullet->w = dest.w;
  bullet->h = dest.h;
  bullet->x += e->w / 2 - bullet->w / 2;
  bullet->y += e->h / 2 - bullet->h / 2;
  calcSlope(player->x + player->w / 2, player->y + player->h / 2, e->x, e->y, bullet->dx, bullet->dy);
  bullet->dx *= ALIEN_BULLET_SPEED;
  bullet->dy *= ALIEN_BULLET_SPEED;
  bullet->side = SIDE_ALIEN;
}

void doEnemies() {
  Entity *e;

  e = stageHead->next;
  while (e != NULL) {
    if (e != player) {
      e->y = MIN(MAX(e->y, 0), SCREEN_HEIGHT - e->h);
      if (e->y <= 0) {
        e->dy *= -1;
      }
      if (e->y >= (SCREEN_HEIGHT - e->h)) {
        e->dy *= -1;
      }
      e->reload--;
      if ((player != NULL) AND (e->reload <= 0)) {
        fireAlienbullet(e);
        e->reload = RANDOM(RAND_MAX) % (FPS * 2);
        playSound(SND_ALIEN_FIRE, CH_ALIEN_FIRE);
      }
    }
    e = e->next;
  }
}
void fireBullet() {
  Entity *bullet;
  SDL_Rect dest;

  bullet = malloc(sizeof(Entity));
  initEntity(bullet);
  stageTail->next = bullet;
  stageTail = bullet;
  bullet->x = player->x;
  bullet->y = player->y;
  bullet->dx = PLAYER_BULLET_SPEED;
  bullet->health = 1;
  bullet->Texture = bulletTexture;
  SDL_QueryTexture(bullet->Texture, NULL, NULL, &dest.w, &dest.h);
  bullet->w = dest.w;
  bullet->h = dest.h;
  bullet->x += player->w / 2;
  bullet->y += player->h / 2 - bullet->h / 2;
  bullet->side = SIDE_PLAYER;
  player->reload = 8;
}

void doPlayer() {
  if (player != NULL) {
    player->dx = 0;
    player->dy = 0;
    if (player->reload > 0) {
      player->reload--;
    }
    if (app.keyboard[SDL_ScanCode_UP] || app.keyboard[SDL_ScanCode_KP_8]) {
      player->dy = -PLAYER_SPEED;
    }
    if (app.keyboard[SDL_ScanCode_DOWN] || app.keyboard[SDL_ScanCode_KP_2]) {
      player->dy = PLAYER_SPEED;
    }
    if (app.keyboard[SDL_ScanCode_LEFT] || app.keyboard[SDL_ScanCode_KP_4]) {
      player->dx = -PLAYER_SPEED;
    }
    if (app.keyboard[SDL_ScanCode_RIGHT] || app.keyboard[SDL_ScanCode_KP_6]) {
      player->dx = PLAYER_SPEED;
    }
    if (app.keyboard[SDL_ScanCode_LCTRL] && player->reload <= 0) {
      fireBullet();
      playSound(SND_PLAYER_FIRE, CH_PLAYER);
    }
  }
}
void logic_Game() {
    doBackGround();
    doStarfield();
    doPlayer();
    doEnemies();
    doFighters();
    doBullets();
    doExplosions();
    doDebris();
    doPointsPods();
    spawnEnemies();
    clipPlayer();
    if (player == NULL) {
        resetTimer--;
        if (resetTimer <= 0) {
            addHighScore(stage.score);
            initHighScore();
        }
    }
}

void initPlayer() {
    TSDL_Rect dest;
    player = malloc(sizeof(Entity));
    initEntity(player);
    stage->fighterTail->next = player;
    stage->fighterTail = player;
    player->health = 1;
    player->x = 100;
    player->y = 100;
    player->Texture = playerTexture;
    SDL_QueryTexture(player->Texture, NULL, NULL, &dest.w, &dest.h);
    player->w = dest.w;
    player->h = dest.h;
    player->side = SIDE_PLAYER;
}

void resetStage() {
    PEntity e, t;
    e = stage->fighterHead->next;
    while (e != NULL) {
        t = e->next;
        free(e);
        e = t;
    }
    e = stage->bulletHead->next;
    while (e != NULL) {
        t = e->next;
        free(e);
        e = t;
    }
    e = stage->pointsHead->next;
    while (e != NULL) {
        t = e->next;
        free(e);
        e = t;
    }
    initEntity(stage->fighterHead);
    initEntity(stage->bulletHead);
    initEntity(stage->pointsHead);
    stage->fighterTail = stage->fighterHead;
    stage->bulletTail = stage->bulletHead;
    stage->pointsTail = stage->pointsHead;
}

void resetLists() {
    PExplosion ex, u;
    PDebris d, v;
    ex = stage->explosionHead->next;
    while (ex != NULL) {
        u = ex->next;
        free(ex);
        ex = u;
    }
    d = stage->debrisHead->next;
    while (d != NULL) {
        v = d->next;
        free(d);
        d = v;
    }
    stage->explosionTail = stage->explosionHead;
    stage->debrisTail = stage->debrisHead;
}

void initStage() {
    app.delegate.logic = Game;
    app.delegate.draw = Game;
    bulletTexture = loadTexture("gfx/playerBullet.png");
    enemyTexture = loadTexture("gfx/enemy.png");
    alienbulletTexture = loadTexture("gfx/alienBullet.png");
    playerTexture = loadTexture("gfx/player.png");
    explosionTexture = loadTexture("gfx/explosion.png");
    pointsTexture = loadTexture("gfx/points.png");
    memset(&app.keyboard, 0, sizeof(app.keyboard));  // Empty keyboard buffer
    resetStage();
    stage->score = 0;
    initPlayer();
    enemyspawnTimer = 0;
    resetTimer = FPS * 3;
}
#define Title_Menue 3

typedef struct {
    int x;
    int y;
    char *Text;
} MenuItem;

typedef struct {
    int w;
    int h;
} SDL_Rect;

typedef struct {
    int x;
    int y;
    int health;
    char *Texture;
    int w;
    int h;
    int side;
    // Other properties
} Entity;

int SCREEN_WIDTH;
int Auswahl = 1;
int Title_Menue = 3;
int reveal;
int reveal_max;
int timeout;
int FPS;
int exitloop;
Entity *player;
Entity *stage;
SDL_Texture *SDL2Texture;
SDL_Texture *shooterTexture;
SDL_Texture *bulletTexture;
SDL_Texture *enemyTexture;
SDL_Texture *alienbulletTexture;
SDL_Texture *playerTexture;
SDL_Texture *explosionTexture;
SDL_Texture *pointsTexture;

void logic_Game();

void initEntity(Entity *entity) {
    // Initialize entity properties
}

void drawBackground() {
    // Draw background
}

void drawStarfield() {
    // Draw starfield
}

void drawText(int x, int y, int r, int g, int b, int textType, char *text) {
    // Draw text
}

void draw_Title() {
    MenuItem PM[Title_Menue];
    SDL_Rect r;
    int i;

    PM[1].x = SCREEN_WIDTH / 2;
    PM[1].y = 480;
    PM[1].Text = "PLAY GAME";

    PM[2].x = PM[1].x;
    PM[2].y = 540;
    PM[2].Text = "OPTIONS";

    PM[3].x = PM[1].x;
    PM[3].y = 600;
    PM[3].Text = "QUIT";

    drawBackground();
    drawStarfield();
    r.x = 0;
    r.y = 0;
    // SDL_QueryTexture(SDL2Texture, NULL, NULL, &r.w, &r.h);
    r.h = MIN(reveal, r.h);
    // blitRect(SDL2Texture, &r, (SCREEN_WIDTH / 2) - (r.w / 2), 100);
    // SDL_QueryTexture(shooterTexture, NULL, NULL, &r.w, &r.h);
    r.h = MIN(reveal, r.h);
    // blitRect(shooterTexture, &r, (SCREEN_WIDTH / 2) - (r.w / 2), 250);

    for (i = 1; i <= Title_Menue; i++) {
        if (i == Auswahl) {
            if (timeout % 40 < 20) {
                // drawText(PM[i].x - 110, PM[i].y, 0, 255, 0, TEXT_LEFT, '>');
                // drawText(PM[i].x - 80, PM[i].y, 0, 255, 0, TEXT_LEFT, PM[i].Text);
            }
        } else {
            // drawText(PM[i].x - 80, PM[i].y, 255, 255, 255, TEXT_LEFT, PM[i].Text);
        }
    }
}

void logic_Title() {
    bool rep = true;
    doBackground();
    doStarfield();

    if (app.keyboard[SDL_ScanCode_UP] == 1) {
        DEC(Auswahl);
        rep = false;
        timeout = FPS * 5;
    }
    if (app.keyboard[SDL_ScanCode_DOWN] == 1) {
        INC(Auswahl);
        rep = false;
        timeout = FPS * 5;
    }

    if (Auswahl < 1) {
        Auswahl = Title_Menue;
    }
    if (Auswahl > Title_Menue) {
        Auswahl = 1;
    }

    if (rep == false) {
        memset(app.keyboard, 0, sizeof(app.Keyboard));
    }

    if (reveal < reveal_max) {
        INC(reveal);
    }

    DEC(timeout);

    if (timeout <= 0) {
        initHighScore();
        reveal = 0;
    }

    if (((app.keyboard[SDL_ScanCode_RETURN] == 1) || (app.keyboard[SDL_ScanCode_KP_ENTER] == 1)
        || (app.keyboard[SDL_ScanCode_SPACE] == 1) || (app.keyboard[SDL_ScanCode_LCTRL] == 1)) && (Auswahl == 1)) {
        Auswahl = 1;
        initStage();
    }

    if (((app.keyboard[SDL_ScanCode_RETURN] == 1) || (app.keyboard[SDL_ScanCode_KP_ENTER] == 1)
        || (app.keyboard[SDL_ScanCode_SPACE] == 1)) && (Auswahl == 2)) {
        app.r_delegate.logic = app.delegate.logic;
        app.r_delegate.draw = app.delegate.draw;
        app.delegate.logic = Menues;
        app.delegate.draw = Menues;
        bMenue = false;
    }

    if (((app.keyboard[SDL_ScanCode_RETURN] == 1) || (app.keyboard[SDL_ScanCode_KP_ENTER] == 1)
        || (app.keyboard[SDL_ScanCode_SPACE] == 1)) && (Auswahl == 3)) {
        exitloop = true;
    }
}

void initTitle() {
    app.delegate.logic = Logo;
    app.delegate.draw = Logo;
    // FillChar(app.keyboard, sizeof(app.Keyboard), 0);
    SDL2Texture = loadTexture("gfx/sdl2.png");
    shooterTexture = loadTexture("gfx/shooter.png");
    SDL_Rect r;
    // SDL_QueryTexture(SDL2Texture, NULL, NULL, &r.w, &r.h);
    reveal_max = r.h;
    reveal = 0;
    timeout = FPS * 5;
}
#include <stdio.h>
#include <stdbool.h>
#include <SDL.h>

#define Max_Menu 5

typedef struct {
    int x;
    int y;
    char *Text;
    char *HText;
} MenuItem;

int SCREEN_WIDTH;
int Auswahl = 1;
int SoundVol = 0;
int MusicVol = 0;
int Max_Menu = 5;
int reveal;
int reveal_max;
int timeout;
int FPS;
int newHighScoreFlag;
int exitloop;

SDL_Texture *backgroundTexture;
SDL_Texture *starfieldTexture;

void logic_HighSC();

void doBackGround() {
    // Perform background logic
}

void doStarfield() {
    // Perform starfield logic
}

void doNameInput() {
    // Implement name input logic
}

void doHighScores() {
    // Implement high scores logic
}

void emptyHighScore() {
    // Implement empty high score logic
}

void drawBackground() {
    // Implement background drawing
}

void drawStarField() {
    // Implement starfield drawing
}

void drawNameInput() {
    // Implement name input drawing
}

void drawHighScores() {
    // Implement high scores drawing
}

void logic_Menue() {
    bool rep = false;
    doBackGround();
    doStarfield();

    if (app.keyboard[SDL_ScanCode_UP] == 1) {
        DEC(Auswahl);
        rep = false;
    }
    if (app.keyboard[SDL_ScanCode_DOWN] == 1) {
        INC(Auswahl);
        rep = false;
    }

    if (Auswahl < 1) {
        Auswahl = Max_Menu;
    }
    if (Auswahl > Max_Menu) {
        Auswahl = 1;
    }

    if ((app.keyboard[SDL_ScanCode_LEFT] == 1) && (Auswahl == 1)) {
        DEC(SoundVol, 1);
        rep = true;
    }

    if ((app.keyboard[SDL_ScanCode_RIGHT] == 1) && (Auswahl == 1)) {
        INC(SoundVol, 1);
        rep = true;
    }

    if ((app.keyboard[SDL_ScanCode_LEFT] == 1) && (Auswahl == 2)) {
        DEC(MusicVol, 4);
        rep = false;
    }

    if ((app.keyboard[SDL_ScanCode_RIGHT] == 1) && (Auswahl == 2)) {
        INC(MusicVol, 4);
        rep = false;
    }

    if ((app.keyboard[SDL_ScanCode_DELETE] == 1) && (Auswahl == 3)) {
        Auswahl = 1;
        timeout = FPS * 5;
        bMenue = false;
        emptyHighScore();
        app.delegate.logic = Highsc;
        app.delegate.draw = Highsc;
    }

    if (((app.keyboard[SDL_ScanCode_RETURN] == 1) || (app.keyboard[SDL_ScanCode_KP_ENTER] == 1)
        || (app.keyboard[SDL_ScanCode_SPACE] == 1)) && (Auswahl == 4)) {
        Auswahl = 1;
        bMenue = false;
        app.delegate.logic = app.r_delegate.logic;
        app.delegate.draw = app.r_delegate.draw;
    }

    if (((app.keyboard[SDL_ScanCode_RETURN] == 1) || (app.keyboard[SDL_ScanCode_KP_ENTER] == 1)
        || (app.keyboard[SDL_ScanCode_SPACE] == 1)) && (Auswahl == Max_Menu)) {
        exitloop = true;
    }

    if (rep == false) {
        memset(app.keyboard, 0, sizeof(app.Keyboard));
    }

    SoundVol = MIN(MAX(SoundVol, 0), MIX_MAX_VOLUME);
    MusicVol = MIN(MAX(MusicVol, 0), MIX_MAX_VOLUME);
    Mix_VolumeChunk(sounds[1], SoundVol);
    Mix_VolumeChunk(sounds[2], SoundVol);
    Mix_VolumeChunk(sounds[3], SoundVol);
    Mix_VolumeChunk(sounds[4], SoundVol);
    Mix_VolumeChunk(sounds[5], SoundVol);
    Mix_VolumeMusic(MusicVol);
}

void draw_Bar(SDL_Rect a, int wwith, int vol, int max) {
    a.w = (wwith - 4) * vol / max;
    SDL_SetRenderDrawColor(app.renderer, 0, 255, 0, 255);
    SDL_RenderFillRect(app.renderer, &a);
    a.x = a.x - 3;
    a.y = a.y - 3;
    a.w = wwith + 3;
    a.h = a.h + 6;
    SDL_SetRenderDrawColor(app.renderer, 255, 255, 255, 255);
    SDL_RenderDrawRect(app.renderer, &a);
}

void draw_Menue() {
    int i, k;
    SDL_Rect r;
    k = Max_Menu + 1;

    MenuItem PM[Max_Menu + 1];
    PM[1].x = 650;
    PM[1].y = 200;
    PM[1].Text = "SOUND VOLUME:";
    PM[1].HText = "PRESS ARROW-KEYS TO CHANGE SOUND VOLUME!";

    PM[2].x = PM[1].x;
    PM[2].y = 280;
    PM[2].Text = "MUSIC VOLUME:";
    PM[2].HText = "PRESS ARROW-KEYS TO CHANGE MUSIC VOLUME!";

    PM[3].x = PM[1].x;
    PM[3].y = 360;
    PM[3].Text = "RESET HIGHSCORE";
    PM[3].HText = "PRESS DEL TO RESET THE HIGHSCORE";

    PM[4].x = PM[1].x;
    PM[4].y = 440;
    PM[4].Text = "BACK TO GAME!";
    PM[4].HText = "PRESS SPACE OR ENTER TO PLAY GAME!";

    PM[5].x = PM[1].x;
    PM[5].y = 520;
    PM[5].Text = "QUIT THE GAME!";
    PM[5].HText = "PRESS SPACE OR ENTER TO QUIT GAME!";

    drawBackground();
    drawStarfield();

    for (i = 1; i <= Max_Menu; i++) {
        if (i == Auswahl) {
            drawText(PM[i].x - 170, PM[i].y, 0, 255, 0, TEXT_CENTER, ">");
            drawText(PM[i].x - 155, PM[i].y, 0, 255, 0, TEXT_LEFT, PM[i].Text);
        } else {
            drawText(PM[i].x - 155, PM[i].y, 255, 255, 255, TEXT_LEFT, PM[i].Text);
        }
    }

    drawText(PM[k].x, PM[k].y, 255, 255, 255, TEXT_CENTER, PM[Auswahl].HText);

    r.x = PM[1].x + 90;
    r.y = 190;
    r.w = 260;
    r.h = 40;
    draw_Bar(r, 284, SoundVol, MIX_MAX_VOLUME);

    r.x = PM[1].x + 90;
    r.y = 270;
    r.w = 260;
    r.h = 40;
    draw_Bar(r, 284, MusicVol, MIX_MAX_VOLUME);

    drawText(PM[1].x + 240, PM[1].y, 255, 255, 255, TEXT_CENTER, NumberFill(SoundVol * 100 / 128));
    drawText(PM[2].x + 240, PM[2].y, 255, 255, 255, TEXT_CENTER, NumberFill(MusicVol * 100 / 128));
    drawText(PM[1].x + 260, PM[1].y, 255, 255, 255, TEXT_LEFT, "%");
    drawText(PM[2].x + 260, PM[2].y, 255, 255, 255, TEXT_LEFT, "%");
}
#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600
#define MAX_SND_CHANNELS 16

typedef struct Texture {
    // Define the texture structure if needed
} Texture;

typedef struct Textur {
    // Define the Textur structure if needed
} Textur;

typedef struct App {
    SDL_Window* Window;
    SDL_Renderer* Renderer;
    const char* inputText;
    // Other fields in the App structure
} App;

typedef struct Stage {
    // Define the Stage structure if needed
} Stage;

App app;
Stage stage;
Mix_Music* music;
Mix_Chunk* sounds[5];
int gTicks;
int newHighScoreFlag;
int exitLoop;
int bMenue;

void errorMessage(const char* message) {
    fprintf(stderr, "Error: %s\n", message);
    // Handle the error as needed
}

void initStageListenPointer() {
    // Initialize stage listen pointer if needed
}

void initBackground() {
    // Initialize the background if needed
}

void initStarfield() {
    // Initialize the starfield if needed
}

void initSounds() {
    // Initialize sounds if needed
}

void initFonts() {
    // Initialize fonts if needed
}

void initHighScoreTable() {
    // Initialize the high score table if needed
}

void loadMusic() {
    // Load music if needed
}

void playMusic(int flag) {
    // Play music based on the flag
}

void writeHighScore() {
    // Write high score data if needed
}

void resetStage() {
    // Reset the stage if needed
}

void resetLists() {
    // Reset lists if needed
}

void initSDL() {
    int rendererFlags = SDL_RENDERER_ACCELERATED;
    int windowFlags = 0;

    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) < 0) {
        errorMessage(SDL_GetError());
    }

    app.Window = SDL_CreateWindow("Shooter 18", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, windowFlags);
    if (app.Window == NULL) {
        errorMessage(SDL_GetError());
    }

    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024) < 0) {
        errorMessage(SDL_GetError());
    }

    Mix_AllocateChannels(MAX_SND_CHANNELS);
    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
    app.Renderer = SDL_CreateRenderer(app.Window, -1, rendererFlags);
    if (app.Renderer == NULL) {
        errorMessage(SDL_GetError());
    }

    IMG_Init(IMG_INIT_PNG | IMG_INIT_JPG);
    SDL_ShowCursor(0);
}

void initGame() {
    app.inputText = "";
    newHighScoreFlag = 0;
    exitLoop = 0;
    bMenue = 0;
    gTicks = SDL_GetTicks();
    music = NULL;

    initStageListenPointer();
    initBackground();
    initStarfield();
    initSounds();
    initFonts();
    initHighScoreTable();
    loadMusic();
    playMusic(1);
}

void destroyTexture() {
    Textur* tex = app.textureHead->next;
    while (tex != NULL) {
        Textur* e = tex->next;
        free(tex);
        tex = e;
    }
}

void cleanUp() {
    writeHighScore();
    resetStage();
    resetLists();
    if (stage.fighterHead != NULL) {
        free(stage.fighterHead);
    }
    if (stage.bulletHead != NULL) {
        free(stage.bulletHead);
    }
    if (stage.explosionHead != NULL) {
        free(stage.explosionHead);
    }
    if (stage.debrisHead != NULL) {
        free(stage.debrisHead);
    }
    if (stage.pointsHead != NULL) {
        free(stage.pointsHead);
    }
    destroyTexture();
    if (app.textureHead != NULL) {
        free(app.textureHead);
    }
    for (int i = 5; i >= 1; i--) {
        Mix_FreeChunk(sounds[i]);
    }
    Mix_FreeMusic(music);
    if (exitLoop != 0) {
        printf("CleanUp complete!\n");
    }
}

void AtExit() {
    if (exitLoop != 0) {
        cleanUp();
    }
    Mix_CloseAudio();
    SDL_DestroyRenderer(app.Renderer);
    SDL_DestroyWindow(app.Window);
    Mix_Quit();
    IMG_Quit();
    SDL_Quit();
    SDL_ShowCursor(1);
}
typedef enum TDelegating {
    Logo,
    HighSC,
    Menues,
    Game
} TDelegating;

SDL_Event Event; // Declare SDL_Event globally

void logic_Title(void);
void draw_Title(void);
void logic_HighSC(void);
void draw_HighSC(void);
void logic_Menue(void);
void draw_Menue(void);
void logic_Game(void);
void draw_Game(void);

void delegate_logic(TDelegating Wahl) {
    switch (Wahl) {
        case Logo:
            logic_Title();
            draw_Title();
            break;
        case HighSC:
            logic_HighSC();
            draw_HighSC();
            break;
        case Menues:
            logic_Menue();
            draw_Menue();
            break;
        case Game:
            logic_Game();
            draw_Game();
            break;
    }
}

void doInput(void) {
    app.inputText = "";

    while (SDL_PollEvent(&Event) == 1) {
        switch (Event.type) {
            case SDL_QUIT:
                exitLoop = 1; // Close window
                break;
            case SDL_MOUSEBUTTONDOWN:
                exitLoop = 1; // Mouse button pressed
                break;
            case SDL_KEYDOWN:
                if (Event.key.repeat == 0 && Event.key.keysym.scancode < MAX_KEYBOARD_KEYS) {
                    app.keyboard[Event.key.keysym.scancode] = 1;
                }
                if (app.keyboard[SDL_SCANCODE_ESCAPE] == 1 && bMenue == 0) {
                    app.r_delegate.logic = app.delegate.logic; // Save the old state
                    app.r_delegate.draw = app.delegate.draw; // Save the old state
                    app.delegate.logic = Menues; // Switch to menu
                    app.delegate.draw = Menues; // Switch to menu
                    bMenue = 1; // Menu is active now
                }
                break;
            case SDL_KEYUP:
                if (Event.key.repeat == 0 && Event.key.keysym.scancode < MAX_KEYBOARD_KEYS) {
                    app.keyboard[Event.key.keysym.scancode] = 0;
                }
                break;
            case SDL_TEXTINPUT:
                app.inputText += Event.text.text;
                break;
        }
    }
}

void CapFrameRate(double* remainder, Uint32* Ticks) {
    long wait;
    long FrameTime;
    wait = 16 + (long)*remainder;
    *remainder -= (double)((long)*remainder);
    FrameTime = SDL_GetTicks() - *Ticks;
    wait -= FrameTime;
    if (wait < 1) {
        wait = 1;
    }
    SDL_Delay(wait);
    *remainder += 0.667;
    *Ticks = SDL_GetTicks();
}

int main(int argc, char* argv[]) {
    RANDOMIZE();
    InitSDL();
    AddExitProc(AtExit);
    initGame();
    initTitle();

    while (exitLoop == 0) {
        prepareScene();
        doInput();
        delegate_logic();
        presentScene();
        CapFrameRate(&gRemainder, &gTicks);
    }

    cleanUp();
    AtExit();

    return 0;
}
